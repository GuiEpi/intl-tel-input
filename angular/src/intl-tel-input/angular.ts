import intlTelInput from "../intl-tel-input";
//* Keep the TS imports separate, as the above line gets substituted in the angularWithUtils build process.
import { Iti } from "../intl-tel-input";
import {
  Component,
  Input,
  OnInit,
  OnDestroy,
  ViewChild,
  ElementRef,
  Output,
  EventEmitter,
  forwardRef,
  AfterViewInit,
  OnChanges,
  SimpleChanges,
} from "@angular/core";
import {
  ControlValueAccessor,
  NG_VALUE_ACCESSOR,
  NG_VALIDATORS,
  Validator,
  AbstractControl,
  ValidationErrors,
} from "@angular/forms";
import type { AllOptions, SomeOptions } from "../modules/types/public-api";

export { intlTelInput };

export const PHONE_ERROR_MESSAGES: string[] = [
  "invalid",
  "invalid-country-code",
  "too-short",
  "too-long",
  "invalid-format",
];

@Component({
  selector: "intl-tel-input",
  standalone: true,
  template: `
    <input
      type="tel"
      #inputRef
      (input)="handleInput()"
      (blur)="handleBlur($event)"
      (focus)="handleFocus($event)"
      (keydown)="handleKeyDown($event)"
      (keyup)="handleKeyUp($event)"
      (paste)="handlePaste($event)"
      (click)="handleClick($event)"
    />
  `,
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => IntlTelInput),
      multi: true,
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => IntlTelInput),
      multi: true,
    },
  ],
})
class IntlTelInput
  implements
    OnInit,
    AfterViewInit,
    OnDestroy,
    OnChanges,
    ControlValueAccessor,
    Validator
{
  @ViewChild("inputRef", { static: true })
  inputRef!: ElementRef<HTMLInputElement>;

  @Input() initialValue: string = "";
  @Input() usePreciseValidation: boolean = false;
  @Input() inputProps: object = {};
  @Input() disabled?: boolean;

  // Plugin initialisation options (one @Input per option)
  @Input() allowDropdown?: AllOptions["allowDropdown"];
  @Input() allowedNumberTypes?: AllOptions["allowedNumberTypes"];
  @Input() allowNumberExtensions?: AllOptions["allowNumberExtensions"];
  @Input() allowPhonewords?: AllOptions["allowPhonewords"];
  @Input() autoPlaceholder?: AllOptions["autoPlaceholder"];
  @Input() containerClass?: AllOptions["containerClass"];
  @Input() countryNameLocale?: AllOptions["countryNameLocale"];
  @Input() countryOrder?: AllOptions["countryOrder"];
  @Input() countrySearch?: AllOptions["countrySearch"];
  @Input() customPlaceholder?: AllOptions["customPlaceholder"];
  @Input() dropdownAlwaysOpen?: AllOptions["dropdownAlwaysOpen"];
  @Input() dropdownContainer?: AllOptions["dropdownContainer"];
  @Input() excludeCountries?: AllOptions["excludeCountries"];
  @Input() fixDropdownWidth?: AllOptions["fixDropdownWidth"];
  @Input() formatAsYouType?: AllOptions["formatAsYouType"];
  @Input() formatOnDisplay?: AllOptions["formatOnDisplay"];
  @Input() geoIpLookup?: AllOptions["geoIpLookup"];
  @Input() hiddenInput?: AllOptions["hiddenInput"];
  @Input() i18n?: AllOptions["i18n"];
  @Input() initialCountry?: AllOptions["initialCountry"];
  @Input() loadUtils?: AllOptions["loadUtils"];
  @Input() nationalMode?: AllOptions["nationalMode"];
  @Input() onlyCountries?: AllOptions["onlyCountries"];
  @Input() placeholderNumberType?: AllOptions["placeholderNumberType"];
  @Input() searchInputClass?: AllOptions["searchInputClass"];
  @Input() separateDialCode?: AllOptions["separateDialCode"];
  @Input() showFlags?: AllOptions["showFlags"];
  @Input() strictMode?: AllOptions["strictMode"];
  @Input() useFullscreenPopup?: AllOptions["useFullscreenPopup"];

  @Output() numberChange = new EventEmitter<string>();
  @Output() countryChange = new EventEmitter<string>();
  @Output() validityChange = new EventEmitter<boolean>();
  @Output() errorCodeChange = new EventEmitter<number | null>();
  @Output() blur = new EventEmitter<FocusEvent>();
  @Output() focus = new EventEmitter<FocusEvent>();
  @Output() keydown = new EventEmitter<KeyboardEvent>();
  @Output() keyup = new EventEmitter<KeyboardEvent>();
  @Output() paste = new EventEmitter<ClipboardEvent>();
  @Output() click = new EventEmitter<MouseEvent>();

  private iti: Iti | null = null;
  private countryChangeHandler = () => this.handleInput();

  private lastEmittedNumber?: string;
  private lastEmittedCountry?: string;
  private lastEmittedValidity?: boolean;
  private lastEmittedErrorCode?: number | null;

  // eslint-disable-next-line class-methods-use-this
  private onChange: (value: string) => void = () => {};
  // eslint-disable-next-line class-methods-use-this
  private onTouched: () => void = () => {};
  // eslint-disable-next-line class-methods-use-this
  private onValidatorChange: () => void = () => {};

  ngOnInit() {
    if (this.inputRef.nativeElement) {
      this.iti = intlTelInput(this.inputRef.nativeElement, this.buildInitOptions());
    }

    this.inputRef.nativeElement.addEventListener(
      "countrychange",
      this.countryChangeHandler,
    );

    this.applyInputProps();
  }

  private buildInitOptions(): SomeOptions {
    const options: Partial<AllOptions> = {
      allowDropdown: this.allowDropdown,
      allowedNumberTypes: this.allowedNumberTypes,
      allowNumberExtensions: this.allowNumberExtensions,
      allowPhonewords: this.allowPhonewords,
      autoPlaceholder: this.autoPlaceholder,
      containerClass: this.containerClass,
      countryNameLocale: this.countryNameLocale,
      countryOrder: this.countryOrder,
      countrySearch: this.countrySearch,
      customPlaceholder: this.customPlaceholder,
      dropdownAlwaysOpen: this.dropdownAlwaysOpen,
      dropdownContainer: this.dropdownContainer,
      excludeCountries: this.excludeCountries,
      fixDropdownWidth: this.fixDropdownWidth,
      formatAsYouType: this.formatAsYouType,
      formatOnDisplay: this.formatOnDisplay,
      geoIpLookup: this.geoIpLookup,
      hiddenInput: this.hiddenInput,
      i18n: this.i18n,
      initialCountry: this.initialCountry,
      loadUtils: this.loadUtils,
      nationalMode: this.nationalMode,
      onlyCountries: this.onlyCountries,
      placeholderNumberType: this.placeholderNumberType,
      searchInputClass: this.searchInputClass,
      separateDialCode: this.separateDialCode,
      showFlags: this.showFlags,
      strictMode: this.strictMode,
      useFullscreenPopup: this.useFullscreenPopup,
    };

    return Object.fromEntries(
      Object.entries(options).filter(([, value]) => value !== undefined),
    ) as SomeOptions;
  }

  ngAfterViewInit() {
    if (this.initialValue) {
      this.iti?.setNumber(this.initialValue);
    }

    if (this.disabled) {
      this.iti?.setDisabled(this.disabled);
    }
  }

  ngOnChanges(changes: SimpleChanges) {
    if (changes["disabled"]) {
      this.iti?.setDisabled(this.disabled || false);
    }
  }

  handleInput() {
    if (!this.iti) return;

    const num = this.iti.getNumber() || "";
    const countryIso = this.iti.getSelectedCountryData().iso2 || "";

    let hasChanged = false;
    if (num !== this.lastEmittedNumber) {
      this.lastEmittedNumber = num;
      this.numberChange.emit(num);
      this.onChange(num);
      hasChanged = true;
    }

    if (countryIso !== this.lastEmittedCountry) {
      this.lastEmittedCountry = countryIso;
      this.countryChange.emit(countryIso);
      hasChanged = true;
    }

    const isValid = this.usePreciseValidation
      ? this.iti.isValidNumberPrecise()
      : this.iti.isValidNumber();

    const errorCode = isValid ? null : this.iti.getValidationError();

    if (isValid !== this.lastEmittedValidity) {
      this.lastEmittedValidity = isValid;
      this.validityChange.emit(isValid);
      hasChanged = true;
    }

    if (errorCode !== this.lastEmittedErrorCode) {
      this.lastEmittedErrorCode = errorCode;
      this.errorCodeChange.emit(errorCode);
      hasChanged = true;
    }

    if (hasChanged) {
      this.onValidatorChange();
    }
  }

  handleBlur(event: FocusEvent) {
    this.onTouched();
    this.blur.emit(event);
  }

  handleFocus(event: FocusEvent) {
    this.focus.emit(event);
  }

  handleKeyDown(event: KeyboardEvent) {
    this.keydown.emit(event);
  }

  handleKeyUp(event: KeyboardEvent) {
    this.keyup.emit(event);
  }

  handlePaste(event: ClipboardEvent) {
    this.paste.emit(event);
  }

  handleClick(event: MouseEvent) {
    this.click.emit(event);
  }

  /**
   * This method must be called in `ngAfterViewInit` or later lifecycle hooks,
   * not in `ngOnInit` or the `constructor`, as the component needs to be fully initialized.
   */
  getInstance(): Iti | null {
    return this.iti;
  }

  /**
   * This method must be called in `ngAfterViewInit` or later lifecycle hooks,
   * not in `ngOnInit` or the `constructor`, as the component needs to be fully initialized.
   */
  getInput(): HTMLInputElement | null {
    return this.inputRef.nativeElement;
  }

  ngOnDestroy() {
    this.iti?.destroy();

    this.inputRef.nativeElement.removeEventListener(
      "countrychange",
      this.countryChangeHandler,
    );
  }

  private applyInputProps(): void {
    const props = this.inputProps;
    Object.entries(props).forEach(([key, value]) => {
      this.inputRef.nativeElement.setAttribute(key, value);
    });
  }

  // ============ ControlValueAccessor Implementation ============

  writeValue(value: string | null): void {
    if (this.iti) {
      this.iti.setNumber(value || "");
    }
  }

  registerOnChange(fn: any): void {
    this.onChange = fn;
  }

  registerOnTouched(fn: any): void {
    this.onTouched = fn;
  }

  setDisabledState(isDisabled: boolean): void {
    this.disabled = isDisabled;
    this.iti?.setDisabled(isDisabled);
  }

  // ============ Validator Implementation ============

  validate(control: AbstractControl): ValidationErrors | null {
    if (!control.value || !this.iti) {
      return null;
    }

    const isValid = this.usePreciseValidation
      ? this.iti.isValidNumberPrecise()
      : this.iti.isValidNumber();

    if (isValid) {
      return null;
    }

    const errorCode = this.iti.getValidationError();
    return {
      invalidPhone: {
        errorCode,
        errorMessage: PHONE_ERROR_MESSAGES[errorCode],
      },
    };
  }

  registerOnValidatorChange(fn: () => void): void {
    this.onValidatorChange = fn;
  }
}
export default IntlTelInput;